Вот детальный анализ проекта **MathFlow**.

Видно, что проект вдохновлен архитектурой GPU и Data-Oriented Design (DOD). Автор пытается реализовать «программный шейдерный конвейер» на чистом C, используя SoA (Structure of Arrays) и свою виртуальную машину.

Код написан чисто, но архитектура страдает от попытки быть слишком универсальной («и тензоры, и пиксели, и логика»). Это привело к ряду **фатальных логических ошибок**, из\-за которых проект будет падать или выдавать некорректную картинку.

### ---

**1\. Архитектура (Mental Model)**

Проект работает как **JIT-компилятор графов** в собственный байт-код.

1. **Компиляция (Compiler):**  
   * Граф (JSON) проходит через "сплющивание" (inlining подграфов).  
   * **Liveness Analysis:** Анализирует время жизни переменных, чтобы переиспользовать «виртуальные регистры» и экономить память (Register Aliasing).  
   * **CodeGen:** Генерирует байт-код (mf\_program), где каждая инструкция содержит жестко зашитые strides (шаги доступа к памяти) для каждого операнда. Это попытка сделать один универсальный цикл для скаляров (stride=0) и массивов (stride=1).  
2. **Исполнение (Engine & Backend):**  
   * Используется **Double Buffering** (Front/Back) для всех глобальных ресурсов.  
   * Бэкенд разбивает задачу (например, рендер текстуры) на чанки (Jobs) по 4096 элементов.  
   * Воркеры исполняют байт-код, интерпретируя инструкции в цикле.

### ---

**2\. Ключевые Логические Ошибки («Мины»)**

В коде есть 4 критических бага. Если их не исправить, проект нежизнеспособен.

#### **А. Ошибка «Схлопывания» Метаданных (Heap Corruption)**

Где: mf\_pass\_liveness.c (анализ) \+ mf\_codegen.c (генерация).  
Суть: Liveness Analysis назначает один регистр (например, R5) разным узлам, если их время жизни не пересекается.

* *Сценарий:* Сначала R5 используется для большого массива (1МБ). Позже R5 используется для скаляра (4 байта).  
* *Ошибка:* В mf\_codegen.c при генерации программы дескриптор регистра **перезаписывается** метаданными текущего узла:  
  C  
  // mf\_codegen.c, line \~60  
  t\_desc-\>info \= node-\>out\_shape.info; // ПЕРЕЗАПИСЬ\!

  В итоге в заголовке программы у R5 останется размер "4 байта".  
* **Результат:** При запуске mf\_engine выделит под R5 всего 4 байта. Когда выполнение дойдет до первого узла (массива), он запишет туда 1МБ данных. **Итог: Переполнение кучи и краш.**  
* **Фикс:** Компилятор должен трекать *максимальный* размер, требуемый регистру за все время его жизни, а не перезаписывать его.

#### **Б. Ошибка «Замороженного Контекста» (Рендер квадратами)**

Где: mf\_backend\_cpu.c.  
Суть: Функция cpu\_worker\_job вычисляет координаты (ctx.tile\_offset) один раз перед началом цикла по 4096 пикселям. Внутри цикла вызывается mf\_cpu\_exec, который передает этот неизменный контекст в операции.

* **Ошибка:** Инструкция MF\_OP\_INDEX (получение координат пикселя) читает данные из ctx. Так как ctx не обновляется внутри цикла по элементам, все 4096 пикселей получат **одну и ту же координату**.  
* **Результат:** Изображение распадется на одноцветные блоки размером с батч.

#### **В. Эвристика SUM (Логическая ошибка)**

Где: mf\_backend\_cpu.c, функция dispatch.  
Суть:

C

if (inst-\>opcode \== MF\_OP\_SUM) {  
    if (batch.strides\[src\] \> 0) batch.strides\[dst\] \= \-1; // Force Reduction  
}

Бэкенд *молча* решает: "Если мы суммируем массив, то это обязательно свертка в одно число".

* **Ошибка:** Это запрещает поэлементное сложение массивов (например, сложить две картинки A \+ B). Движок схлопнет результат в один пиксель.  
* **Фикс:** Редукция должна быть явным свойством опкода (MF\_OP\_REDUCE\_SUM), а не магией на основе страйдов.

#### **Г. NaN Poisoning и Gather Crash**

Где: docs/roadmap.md (упоминание краша) и логика Gather.  
Суть: Узлы Clamp работают с float. Если математика (например, деление на 0 в Normalize) породила NaN, Clamp пропустит его дальше. Приведение (int)NaN в Си — это Undefined Behavior (часто INT\_MIN или 0).

* **Результат:** Gather получает дикий индекс и лезет за пределы памяти до проверки границ (которая часто делается пост-фактум или не спасает от UB при касте).

### ---

**3\. Архитектурные Проблемы**

#### **1\. Лаг Композиции (Double Buffering Trap)**

Движок навязывает Double Buffering (Front/Back) для **всех** ресурсов.

* *Проблема:* Это нужно только для симуляций (где кадр N зависит от N-1). Для графического пайплайна (Render \-\> PostProcess) это создает **лаг в 1 кадр**. PostProcess будет читать результат Render из *прошлого* кадра, так как текущий (Back) закрыт на запись.  
* *Решение:* Ввести тип ресурсов Transient (временные), которые живут внутри одного кадра без буферизации.

#### **2\. "Жирные" Инструкции**

Структура mf\_instruction хранит массив i32 strides\[5\]. Это раздувает байт-код и убивает кэш инструкций CPU. Страйды — это свойство данных/регистров, их не нужно дублировать в каждой команде.

#### **3\. Накладные расходы на каждый чанк**

В cpu\_worker\_job происходит полная переинициализация контекста (mf\_exec\_ctx\_init, prepare\_registers с копированием структур) для каждого пакета работы. При Full HD это тысячи лишних аллокаций/копирований в кадр.

### ---

**4\. План Рефакторинга (Make it Cleaner)**

Нужно упростить модель, разделив "Логику" и "Математику".

#### **Шаг 1: Разделение на Scalar Pass и Kernel Pass**

Отказаться от попыток угадать "домены". Разделить граф явно:

1. **Preamble (Scalar Pass):** Выполняется 1 раз на кадр на главном потоке. Считает все Uniforms (время, матрицы, UI). Пишет в маленький буфер констант.  
2. **Kernel (Vector Pass):** Выполняется N раз. Получает скаляры как готовые значения.  
* *Профит:* Убирает проверки stride из горячего цикла. Упрощает компилятор (не нужно Domain Splitting).

#### **Шаг 2: Упрощение памяти (Frame Arena)**

Убрать сложный mf\_heap с Free List для временных данных.  
Ввести Linear Frame Arena:

* В начале кадра аллокатор сбрасывается в 0\.  
* Все временные регистры и контексты просто двигают указатель (ptr \+= size).  
* Никаких free() в рантайме. Нулевая фрагментация.

#### **Шаг 3: Нативные "Супер-Инструкции"**

Вернуть математику (SmoothStep, Mix, Length) из JSON-подграфов в C-код (mf\_ops). Интерпретация графа для SmoothStep (это 10+ простых инструкций) в 50 раз медленнее, чем одна нативная функция C.

#### **Шаг 4: Запекание (Baking) перед исполнением**

Вместо того чтобы воркеры каждый раз копировали mf\_tensor и считали оффсеты:

1. Перед запуском пула движок готовит массив "сырых" указателей void\* ptrs\[\].  
2. Воркер получает только индекс i.  
3. Доступ к данным превращается в ptrs\[reg\] \+ i (для векторов) или ptrs\[reg\] (для скаляров).  
4. Никаких структур mf\_tensor внутри цикла.

### **Итог**

Проект написан качественно, но архитектурно переусложнен абстракциями.  
Срочно исправить: Баг с перезаписью метаданных в mf\_codegen (иначе проект будет падать случайным образом).  
Глобально: Внедрить разделение на Скалярную и Векторную части — это превратит его из "медленного универсального комбайна" в быстрый пиксельный движок.